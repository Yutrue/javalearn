异常：
是对问题的描述，将问题进行对象的封装

异常体系：
	Throwable
		|--Error
		|--Exception
			|--RuntimeException

异常体系的特点：异常体系中的所有类以及建立的对象都具备可抛性
							 也就是说可以被throw和throws关键字所操作
							 只有异常体系具备这个特点

throw和throws关键字的用法：
throw定义在函数内，用于抛出异常对象
throws定义在函数上，用于抛出异常类，可以抛出多个用逗号隔开

当函数内容有throw抛出异常对象，并未进行try处理。必须在函数上声明，否则编译失败
注意，RuntimeException除外，也就是说，函数内如果抛出的RuntimeException异常，函数上可以不用声明

如果函数声明了异常，调用者需要进行处理：throws或者try

异常有两种：
	编译时被检测异常
			该异常在编译时，如果没有处理（没有抛出也没有utry），编译失败
			该异常被标识，代表这可以被处理
	运行时异常（编译时不检测）
			在编译时，不需要处理，编译器不检查
			该异常的发生，建议不处理，让程序停止。需要对代码修正
		
异常处理语句：（三种结合方式：排列）
try
{
	需要被检测的代码；
}
catch ()
{
	处理异常的代码；
}
finally
{
	一定会执行的代码；
}

注意：	
1.finally中定义的通常是 关闭资源代码，因为资源必须释放
2.finally只有一种情况不会执行，当执行到System.exit(0)；（关闭jvm）

自定义异常：
	定义类继承Exception或者RuntimeException
	1.为了让该自定义类具备可抛性
	2.让该类具备操作异常的共性方法

	当要定义自定义异常的信息时，可以使用父类已经定义好的功能，将异常信息传进来
	异常信息传递给父类的构造函数
	class MyException extends Exception
	{
		MyException(String msg)
		{
			super(msg);
		}
	}

自定义异常：按照java的面相对象思想，将程序中出现的特有问题进行封装

异常的好处：
	1.将问题进行封装
	2.将正常流程代码和问题流程代码相分离，方便于阅读

异常的处理原则：
	1.处理方式有两种：try 或者 throws。
	2.调用到抛出的功能时，抛出及格，就处理几个
			一个try对应多个catch
	3.多个catch，父类的catch放到最下面
	4.catch内，需要定义针对性的处理方式，不要简单地定义printStackTrace，输出语句。
		也不要不写。
		当捕获到的异常，本功能处理不了时，可以继续在catch中抛出。
		try
		{
			throw new AException();
		}
		catch (AException e)
		{
			throw e;
		}

		如果该异常处理不了，但并不属于该功能出现的异常
		可以将异常转换后，再抛出和该功能相关的异常

		或者异常可以处理，但需要将异常产生的和本功能相关的问题提供出去
		当调用者知道，并处理。也可以将捕获异常处理后，转换新的异常
		try
		{
			throw new AException();
		}
		catch (AException e)
		{
			//对AException处理
			throw new BException();
		}

异常在子父类覆盖中的体现：
1.子类在覆盖父类时，如果父类的方法抛出异常，那么子类的覆盖方法，只能抛出父类的异常或者该异常的子类
2.如果父类方法抛出多个异常，那么子类在覆盖方法时，只能抛出父类异常的子集
3.如果父类或者接口的方法中没有异常抛出，那么子类在覆盖方法时，也不可以抛出异常
如果子类方法中发生了异常。就必须要进行try处理，绝对不能抛

